<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>‰ºùË™¨„ÅÆ„Åü„Å¨„ÅçÂè©„Åç</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  overflow: hidden;
  background: #2d1b0e;
  font-family: 'Segoe UI', 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

canvas {
  display: block;
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="8" r="7" fill="%238B4513" stroke="%23000" stroke-width="1.5"/><rect x="17" y="8" width="6" height="28" rx="3" fill="%23D2691E" stroke="%23000" stroke-width="1.5"/></svg>') 20 8, pointer;
}

#ui-overlay {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 10;
}

#top-bar {
  position: absolute;
  top: 0; left: 0; right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 14px;
  background: linear-gradient(180deg, rgba(0,0,0,0.5) 0%, transparent 100%);
  flex-wrap: wrap;
}

#score-display {
  font-size: 20px;
  font-weight: bold;
  color: #FFD700;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}

#combo-display {
  font-size: 16px;
  font-weight: bold;
  color: #ff6600;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  transition: transform 0.1s;
}

#set-display {
  font-size: 15px;
  font-weight: bold;
  color: #88ccff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}

#timer-display {
  font-size: 22px;
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  min-width: 32px;
  text-align: right;
}

#level-display {
  position: absolute;
  top: 44px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 14px;
  color: #ffcc66;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
  white-space: nowrap;
}

#chance-banner {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  font-size: clamp(20px, 5vw, 36px);
  font-weight: 900;
  color: #FFD700;
  text-shadow: 0 0 15px #ff6600, 0 0 30px #ff3300, 2px 2px 4px rgba(0,0,0,0.8);
  white-space: nowrap;
  display: none;
  animation: chancePulse 0.5s infinite alternate;
  z-index: 12;
  pointer-events: none;
}

@keyframes chancePulse {
  0% { transform: translateX(-50%) scale(1); color: #FFD700; }
  100% { transform: translateX(-50%) scale(1.1); color: #ff8800; }
}

#message-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.6);
  pointer-events: auto;
  z-index: 20;
}

#message-overlay.hidden { display: none; }

#message-title {
  font-size: clamp(28px, 6vw, 48px);
  font-weight: 900;
  color: #FFD700;
  text-shadow: 3px 3px 8px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.4);
  text-align: center;
  margin-bottom: 10px;
  line-height: 1.3;
}

#message-sub {
  font-size: clamp(14px, 3vw, 22px);
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
  text-align: center;
  margin-bottom: 8px;
  line-height: 1.5;
  max-width: 90vw;
}

#message-comment {
  font-size: clamp(16px, 3.5vw, 26px);
  font-weight: bold;
  color: #ff9933;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
  text-align: center;
  margin-bottom: 20px;
  line-height: 1.5;
  max-width: 90vw;
}

#message-action {
  font-size: clamp(14px, 3vw, 20px);
  color: #ccc;
  text-align: center;
  animation: blink 1.2s infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

#floating-texts {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 15;
}

.float-text {
  position: absolute;
  font-weight: 900;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
  animation: floatUp 1s ease-out forwards;
  pointer-events: none;
  white-space: nowrap;
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  70% { opacity: 1; transform: translateY(-60px) scale(1.2); }
  100% { opacity: 0; transform: translateY(-100px) scale(0.8); }
}

.miss-text { color: #ff4444; font-size: 24px; }
.hit-text { color: #FFD700; font-size: 28px; }
.combo-text { color: #ff6600; font-size: 34px; }
.bonus-text { color: #ff00ff; font-size: 32px; }
.chance-text { color: #FFD700; font-size: 38px; text-shadow: 0 0 20px #ff6600; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui-overlay">
  <div id="top-bar">
    <div id="score-display">0 ÁÇπ</div>
    <div id="set-display"></div>
    <div id="combo-display"></div>
    <div id="timer-display">20</div>
  </div>
  <div id="level-display"></div>
  <div id="chance-banner">‚òÖ „ÉÅ„É£„É≥„Çπ„Çø„Ç§„É†ÔºÅÔºÅ ‚òÖ</div>
</div>

<div id="message-overlay">
  <div id="message-title">‰ºùË™¨„ÅÆ„Åü„Å¨„ÅçÂè©„Åç</div>
  <div id="message-sub">Á©¥„Åã„ÇâÂá∫„Å¶„Åè„Çã„Åü„Å¨„Åç„ÇíÂè©„ÅëÔºÅ<br><span style="color:#ff4444">Ëµ§„ÅèÂÖâ„Çã„Äå„Éã„Çª„É¢„Éé„Äç„ÅØÂè©„Åè„Å™ÔºÅ</span><br><span style="color:#88ffaa">‚òÖ„Éû„Éº„ÇØ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Åß„ÉÅ„É£„É≥„Çπ„Çø„Ç§„É†ÔºÅ</span></div>
  <div id="message-comment"></div>
  <div id="message-action">„Çø„ÉÉ„Éó / „ÇØ„É™„ÉÉ„ÇØ „Åß„Çπ„Çø„Éº„Éà</div>
</div>

<div id="floating-texts"></div>

<script>
// ===== Canvas Setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  calculateLayout();
}

// ===== Layout =====
let holes = [];
let holeRadius = 40;
let tanukiSize = 30;

function calculateLayout() {
  const w = canvas.width;
  const h = canvas.height;
  const isPortrait = h > w;
  holes = [];

  if (isPortrait) {
    const cols = 3, rows = 3;
    const startY = h * 0.28;
    const endY = h * 0.82;
    const startX = w * 0.15;
    const endX = w * 0.85;
    holeRadius = Math.min(w / 8, 50);
    tanukiSize = holeRadius * 0.75;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        holes.push({
          x: startX + (endX - startX) * c / (cols - 1),
          y: startY + (endY - startY) * r / (rows - 1),
          tanuki: null, hitAnim: 0, missAnim: 0,
        });
      }
    }
  } else {
    const cols = 3, rows = 3;
    const startY = h * 0.25;
    const endY = h * 0.85;
    const startX = w * 0.2;
    const endX = w * 0.8;
    holeRadius = Math.min(w / 12, 55);
    tanukiSize = holeRadius * 0.75;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        holes.push({
          x: startX + (endX - startX) * c / (cols - 1),
          y: startY + (endY - startY) * r / (rows - 1),
          tanuki: null, hitAnim: 0, missAnim: 0,
        });
      }
    }
  }
}

resize();
window.addEventListener('resize', resize);

// ===== Game Constants =====
const SET_COUNT = 5;
const SET_DURATION = 20;
const CHANCE_DURATION = 6;

const TANUKI_TYPES = {
  NORMAL: 'normal',
  GOLDEN: 'golden',
  BOSS: 'boss',
  BOMB: 'bomb',
  SPEEDY: 'speedy',
  ITEM: 'item',
};

// ===== Game State =====
const State = { TITLE: 0, PLAYING: 1, SET_RESULT: 2, RESULT: 3 };
let state = State.TITLE;
let score = 0;
let combo = 0;
let maxCombo = 0;
let hitCount = 0;
let missCount = 0;
let totalSpawned = 0;
let timeLeft = SET_DURATION;
let level = 1;
let bestScore = parseInt(localStorage.getItem('tanuki_whack_best') || '0');
let spawnTimer = 0;
let spawnInterval = 1.2;
let particles = [];
let shakeAmount = 0;
let gameTime = 0;
let levelUpAnim = 0;

// Set system
let currentSet = 1;
let setScores = [];
let setHits = [];

// Chance time
let chanceTime = 0;
let chanceTimeActive = false;
let itemSpawnCooldown = 0;

// ===== Funny Comments =====
const resultComments = {
  legendary: [
    "„Åü„Å¨„ÅçÁïå„Å´ÊÅê„Çå„Çâ„Çå„ÇãÂ≠òÂú®...",
    "„ÅÇ„Å™„Åü„ÅØ„ÇÇ„ÅØ„ÇÑ‰ºùË™¨„ÅÆÂè©„ÅçÂ∏´ÔºÅ",
    "„Åü„Å¨„Åç„Äå„ÇÇ„ÅÜÂá∫„Å¶„Åç„Åü„Åè„Å™„ÅÑ...„Äç",
    "„Åü„Å¨„ÅçÈÄ£Âêà‰ºö„Åã„ÇâËã¶ÊÉÖ„ÅåÊù•„Å¶„ÅÑ„Åæ„Åô",
    "ÂõΩÂÆùÁ¥ö„ÅÆ„Åü„Å¨„ÅçÂè©„ÅçÔºÅÊñáÂåñË≤°„Å´ÁôªÈå≤„Åó„Åæ„Åô",
  ],
  great: [
    "„Åü„Å¨„Åç„Äå„Åì„ÅÆ‰∫∫„Éû„Ç∏„Åß„ÇÑ„Å∞„ÅÑ„Äç",
    "„Å™„Åã„Å™„Åã„ÅÆËÖïÂâçÔºÅ„Åü„Å¨„Åç„ÅåÈúá„Åà„Å¶„ÅÑ„Çã",
    "„Åü„Å¨„ÅçÂ∏´ÁØÑ‰ª£„ÅÆÁß∞Âè∑„ÇíÊéà„Åë„Çà„ÅÜÔºÅ",
    "„Åü„Å¨„Åç„ÅÆÊÇ≤È≥¥„ÅåËÅû„Åì„Åà„Çã...",
    "„Åì„ÅÆ„Åæ„ÅæË°å„Åë„Å∞‰ºùË™¨„Å´„Å™„Çå„Çã„Åã„ÇÇÔºÅ",
  ],
  good: [
    "„Åæ„ÅÇ„Åæ„ÅÇ„ÅÆÊàêÁ∏æÔºÅ„Åü„Å¨„Åç„ÇÇÊ≤πÊñ≠„Åó„Å¶„ÅÑ„Çã",
    "„Åü„Å¨„Åç„Äå„Å°„Çá„Å£„Å®„ÅØÁóõ„Åã„Å£„Åü„Çà„Äç",
    "‰∏≠Á¥ö„Åü„Å¨„ÅçÂè©„ÅçÂ£´„Å´Ë™çÂÆöÔºÅ",
    "„ÇÇ„ÅÜÂ∞ë„Åó„Åß„Åü„Å¨„Åç„Éû„Çπ„Çø„Éº„Å†ÔºÅ",
    "„Åü„Å¨„Åç„Å®„ÅÆÊà¶„ÅÑ„ÅØ„Åæ„Å†Â∫èÁ´†...",
  ],
  normal: [
    "„Åü„Å¨„Åç„Äå‰ΩôË£ï„Å†„Å£„Åü„Çè„Äú„Äç",
    "„Åæ„Å†„Åæ„Å†‰øÆË°å„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºÅ",
    "„Åü„Å¨„Åç„Å´Ëàê„ÇÅ„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô...",
    "Ê¨°„ÅØ„ÇÇ„Å£„Å®Âè©„Åë„Çã„ÅØ„ÅöÔºÅ„Åü„Å∂„ÇìÔºÅ",
    "„Åü„Å¨„Åç„Äå„Åæ„ÅüÈÅä„Åº„ÅÜ„Å≠„Äú„Äç",
  ],
  bad: [
    "„Åü„Å¨„Åç„ÅåÁàÜÁ¨ë„Åó„Å¶„ÅÑ„Åæ„Åô",
    "„Åü„Å¨„Åç„ÄåÂº±„Åô„Åé„ÉØ„É≠„Çø„Äç",
    "„ÇÇ„Åó„Åã„Åó„Å¶...„Åü„Å¨„Åç„ÅÆÂë≥ÊñπÔºü",
    "„Åü„Å¨„Åç„Å´Âåñ„Åã„Åï„Çå„Å¶„Çã„ÅÆ„Åß„ÅØÔºü",
    "„Åü„Å¨„Åç„Äå„ÅäËèìÂ≠ê„Åè„Çå„Åü„ÇâË®±„Åô„Äç",
  ],
};

const setComments = [
  "„Ç¶„Ç©„Éº„Éü„É≥„Ç∞„Ç¢„ÉÉ„ÉóÂÆå‰∫ÜÔºÅ",
  "„Ç®„É≥„Ç∏„É≥„Åã„Åã„Å£„Å¶„Åç„Åü„Å™ÔºÅ",
  "ÂæåÂçäÊà¶Á™ÅÂÖ•ÔºÅÊ∞óÂêà„ÅÑÂÖ•„Çå„ÇçÔºÅ",
  "„ÅÇ„Å®Â∞ë„ÅóÔºÅÂÖ®Âäõ„ÅßË°å„ÅëÔºÅ",
];

const hitComments = [
  "„Éä„Ç§„ÇπÔºÅ", "„ÅÑ„ÅÑ„ÅûÔºÅ", "„ÇÑ„Çã„Å≠ÔºÅ", "„Åô„Åî„ÅÑÔºÅ",
  "„ÅäË¶ã‰∫ãÔºÅ", "„Éê„Ç∑„ÉÉÔºÅ", "„Éâ„Ç´„ÉÉÔºÅ", "„ÅΩ„Åã„Å£ÔºÅ",
];

const comboComments = {
  3: "3„Ç≥„É≥„ÉúÔºÅ„ÅÑ„ÅÑË™øÂ≠êÔºÅ",
  5: "5„Ç≥„É≥„ÉúÔºÅÊ≠¢„Åæ„Çâ„Å™„ÅÑÔºÅ",
  7: "7„Ç≥„É≥„ÉúÔºÅË¶öÈÜí„Åó„Å¶„ÇãÔºÅ",
  10: "10„Ç≥„É≥„ÉúÔºÅÔºÅÈ¨ºÁ•û„ÅÆÂ¶Ç„ÅóÔºÅ",
  15: "15„Ç≥„É≥„ÉúÔºÅÔºÅÔºÅ‰ºùË™¨„ÅÆÂßã„Åæ„ÇäÔºÅ",
  20: "20„Ç≥„É≥„ÉúÔºÅÔºÅÔºÅÔºÅ„ÇÇ„ÅØ„ÇÑÁ•ûÔºÅ",
};

const missComments = [
  "„ÅÇ„Å£...", "ÈÄÉ„Åí„ÅüÔºÅ", "„Çπ„Ç´„ÉÉ", "ÊÉú„Åó„ÅÑÔºÅ",
  "„Åü„Å¨„Åç„Éã„É§„É™", "„Éï„Çß„Ç§„É≥„ÉàÔºÅ",
];

const bombHitComments = [
  "„Éú„Ç´„Éº„É≥ÔºÅÂÅΩÁâ©„Å†„Å£„ÅüÔºÅ",
  "„Åù„Çå„Éã„Çª„É¢„ÉéÔºÅ",
  "„Éà„É©„ÉÉ„Éó„Å´Âºï„Å£„Åã„Åã„Å£„ÅüÔºÅ",
  "„Åü„Å¨„Åç„ÅÆÁΩ†„Å´„Éè„Éû„Å£„ÅüÔºÅ",
];

const levelUpComments = [
  "„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ„Åü„Å¨„Åç„ÄÅÊú¨Ê∞óÂá∫„ÅôÔºÅ",
  "ÈÄü„Åè„Å™„Çã„ÅûÔºÅÊ∞ó„Çí„Å§„Åë„ÇçÔºÅ",
  "„Åü„Å¨„Åç„Åü„Å°„ÅåÊÄí„Å£„Å¶„ÅÑ„ÇãÔºÅ",
  "„Åæ„Å†„Åæ„Å†Ë°å„Åè„ÅûÔºÅ",
  "ÊúÄÈ´òÈÄüÂ∫¶Á™ÅÂÖ•ÔºÅ",
];

const chanceStartComments = [
  "„ÉÅ„É£„É≥„Çπ„Çø„Ç§„É†Á™ÅÂÖ•ÔºÅÂè©„Åç„Åæ„Åè„ÇåÔºÅ",
  "„É¨„Ç¢„Åü„Å¨„ÅçÂ§ßÈáèÁô∫ÁîüÔºÅÔºÅ",
  "„Éú„Éº„Éä„Çπ„Çπ„ÉÜ„Éº„Ç∏ÔºÅÈÄÉ„Åô„Å™ÔºÅ",
];

// ===== Floating Text System =====
function showFloatingText(x, y, text, className) {
  const container = document.getElementById('floating-texts');
  const el = document.createElement('div');
  el.className = 'float-text ' + className;
  el.textContent = text;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  container.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

// ===== Particle System =====
function spawnParticles(x, y, count, color, speed) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = (speed || 5) * (0.3 + Math.random() * 0.7);
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 2,
      life: 1,
      color: color,
      size: 2 + Math.random() * 4,
    });
  }
}

function spawnStars(x, y, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = 3 + Math.random() * 5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 3,
      life: 1,
      color: '#FFD700',
      size: 3 + Math.random() * 3,
      isStar: true,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    if (p.isStar) {
      drawStar(p.x, p.y, p.size, p.size * 0.4, 5);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function drawStar(cx, cy, outerR, innerR, points) {
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const a = (i * Math.PI / points) - Math.PI / 2;
    if (i === 0) ctx.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
    else ctx.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
  }
  ctx.closePath();
  ctx.fill();
}

// ===== Drawing Functions =====
function drawBackground() {
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, '#1a472a');
  grad.addColorStop(0.15, '#2d5a3f');
  grad.addColorStop(0.3, '#5c3a1e');
  grad.addColorStop(0.6, '#4a2e14');
  grad.addColorStop(1, '#3a2210');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#2d7a3a';
  ctx.fillRect(0, 0, canvas.width, canvas.height * 0.18);

  const grassY = canvas.height * 0.18;
  ctx.fillStyle = '#3a8f48';
  for (let x = 0; x < canvas.width; x += 20) {
    ctx.beginPath();
    ctx.moveTo(x, grassY);
    ctx.quadraticCurveTo(x + 10, grassY + 12, x + 20, grassY);
    ctx.fill();
  }

  ctx.fillStyle = 'rgba(90, 60, 30, 0.3)';
  for (let i = 0; i < 8; i++) {
    const px = ((i * 173 + 50) % canvas.width);
    const py = canvas.height * 0.4 + ((i * 97) % (canvas.height * 0.4));
    ctx.beginPath();
    ctx.ellipse(px, py, 30 + i * 5, 15 + i * 2, i * 0.3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Chance time golden border
  if (chanceTimeActive) {
    const flash = 0.3 + Math.sin(gameTime * 8) * 0.2;
    ctx.globalAlpha = flash;
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 8;
    ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
    ctx.globalAlpha = 1;
  }
}

function drawHole(hole) {
  const { x, y } = hole;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(x, y + holeRadius * 0.6, holeRadius * 1.3, holeRadius * 0.4, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#1a0e06';
  ctx.beginPath();
  ctx.ellipse(x, y, holeRadius, holeRadius * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#3d2b1a';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(x, y, holeRadius, holeRadius * 0.45, 0, 0, Math.PI * 2);
  ctx.stroke();

  ctx.strokeStyle = '#2a1c0f';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(x, y, holeRadius * 0.8, holeRadius * 0.35, 0, 0, Math.PI * 2);
  ctx.stroke();

  if (hole.hitAnim > 0) {
    ctx.globalAlpha = hole.hitAnim;
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.ellipse(x, y, holeRadius * 1.3, holeRadius * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  if (hole.missAnim > 0) {
    ctx.globalAlpha = hole.missAnim * 0.5;
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.ellipse(x, y, holeRadius * 1.3, holeRadius * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawTanuki(x, y, s, type, popProgress, wobble) {
  ctx.save();

  const riseOffset = (1 - popProgress) * s * 2.2;
  const tanukiY = y - s * 0.6 - riseOffset;

  ctx.beginPath();
  ctx.rect(0, 0, canvas.width, y - holeRadius * 0.1);
  ctx.clip();

  ctx.translate(x, tanukiY);

  const wobbleAngle = Math.sin(wobble * 8) * 0.08;
  ctx.rotate(wobbleAngle);

  let scale = 1;
  if (type === TANUKI_TYPES.BOSS) scale = 1.3;
  if (type === TANUKI_TYPES.SPEEDY) scale = 0.85;
  if (type === TANUKI_TYPES.ITEM) scale = 0.95;
  ctx.scale(scale, scale);

  let bodyColor, bellyColor, darkColor;
  switch (type) {
    case TANUKI_TYPES.GOLDEN:
      bodyColor = '#DAA520'; bellyColor = '#FFD700'; darkColor = '#8B6914'; break;
    case TANUKI_TYPES.BOMB:
      bodyColor = '#5a1a5a'; bellyColor = '#8a3a8a'; darkColor = '#3a0a3a'; break;
    case TANUKI_TYPES.BOSS:
      bodyColor = '#8B4513'; bellyColor = '#D2691E'; darkColor = '#3E1A00'; break;
    case TANUKI_TYPES.SPEEDY:
      bodyColor = '#a0783c'; bellyColor = '#d4b87a'; darkColor = '#5a4020'; break;
    case TANUKI_TYPES.ITEM:
      bodyColor = '#44bb88'; bellyColor = '#88ffcc'; darkColor = '#226644'; break;
    default:
      bodyColor = '#8B6914'; bellyColor = '#D4A847'; darkColor = '#3E2723';
  }

  // === ITEM: rainbow glow ===
  if (type === TANUKI_TYPES.ITEM) {
    const hue = (wobble * 200) % 360;
    const glow = 0.35 + Math.sin(wobble * 6) * 0.15;
    ctx.globalAlpha = glow;
    ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
    ctx.beginPath();
    ctx.arc(0, -s * 0.2, s * 0.95, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // === BOMB: red danger aura ===
  if (type === TANUKI_TYPES.BOMB) {
    const flash = 0.4 + Math.sin(wobble * 10) * 0.3;
    ctx.globalAlpha = flash;
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -s * 0.2, s * 0.9, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Body
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.15, s * 0.7, s * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();

  // Belly
  ctx.fillStyle = bellyColor;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.2, s * 0.45, s * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.arc(0, -s * 0.35, s * 0.45, 0, Math.PI * 2);
  ctx.fill();

  // Ears
  ctx.fillStyle = darkColor;
  ctx.beginPath(); ctx.arc(-s * 0.32, -s * 0.72, s * 0.14, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(s * 0.32, -s * 0.72, s * 0.14, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ffb6c1';
  ctx.beginPath(); ctx.arc(-s * 0.32, -s * 0.72, s * 0.08, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(s * 0.32, -s * 0.72, s * 0.08, 0, Math.PI * 2); ctx.fill();

  // Eye patches
  ctx.fillStyle = darkColor;
  ctx.beginPath(); ctx.ellipse(-s * 0.18, -s * 0.4, s * 0.16, s * 0.12, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(s * 0.18, -s * 0.4, s * 0.16, s * 0.12, 0.2, 0, Math.PI * 2); ctx.fill();

  // === Eyes per type ===
  if (type === TANUKI_TYPES.BOMB) {
    // Red outline
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.ellipse(0, s * 0.15, s * 0.73, s * 0.58, 0, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(0, -s * 0.35, s * 0.48, 0, Math.PI * 2); ctx.stroke();

    // Big X eyes
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3.5;
    const eyeSize = s * 0.12;
    ctx.beginPath();
    ctx.moveTo(-s * 0.18 - eyeSize, -s * 0.42 - eyeSize);
    ctx.lineTo(-s * 0.18 + eyeSize, -s * 0.42 + eyeSize);
    ctx.moveTo(-s * 0.18 + eyeSize, -s * 0.42 - eyeSize);
    ctx.lineTo(-s * 0.18 - eyeSize, -s * 0.42 + eyeSize);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s * 0.18 - eyeSize, -s * 0.42 - eyeSize);
    ctx.lineTo(s * 0.18 + eyeSize, -s * 0.42 + eyeSize);
    ctx.moveTo(s * 0.18 + eyeSize, -s * 0.42 - eyeSize);
    ctx.lineTo(s * 0.18 - eyeSize, -s * 0.42 + eyeSize);
    ctx.stroke();

    // "„Éã„Çª„É¢„Éé!" label
    ctx.fillStyle = '#ff0000';
    ctx.font = `bold ${s * 0.32}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText('„Éã„Çª„É¢„Éé!', 0, -s * 0.85);
    ctx.fillText('„Éã„Çª„É¢„Éé!', 0, -s * 0.85);

    // Angry mark
    ctx.fillStyle = '#ff3333';
    ctx.font = `${s * 0.3}px sans-serif`;
    ctx.fillText('üí¢', s * 0.4, -s * 0.6);
  } else if (type === TANUKI_TYPES.ITEM) {
    // Star eyes
    ctx.fillStyle = '#FFD700';
    drawStar(-s * 0.16, -s * 0.42, s * 0.1, s * 0.04, 5);
    drawStar(s * 0.16, -s * 0.42, s * 0.1, s * 0.04, 5);

    // "‚òÖ" label above
    ctx.fillStyle = '#FFD700';
    ctx.font = `bold ${s * 0.35}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeText('‚òÖITEM‚òÖ', 0, -s * 0.88);
    ctx.fillText('‚òÖITEM‚òÖ', 0, -s * 0.88);
  } else {
    // Normal eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-s * 0.16, -s * 0.42, s * 0.09, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(s * 0.16, -s * 0.42, s * 0.09, 0, Math.PI * 2); ctx.fill();
    const lookX = Math.sin(wobble * 3) * s * 0.02;
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(-s * 0.15 + lookX, -s * 0.42, s * 0.045, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(s * 0.17 + lookX, -s * 0.42, s * 0.045, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-s * 0.17, -s * 0.44, s * 0.025, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(s * 0.15, -s * 0.44, s * 0.025, 0, Math.PI * 2); ctx.fill();
  }

  // Nose
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.28, s * 0.06, s * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  if (type === TANUKI_TYPES.BOMB) {
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, -s * 0.18, s * 0.08, Math.PI + 0.3, -0.3); ctx.stroke();
  } else if (type === TANUKI_TYPES.GOLDEN || type === TANUKI_TYPES.ITEM) {
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0, -s * 0.23, s * 0.08, 0.2, Math.PI - 0.2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,150,150,0.5)';
    ctx.beginPath(); ctx.ellipse(-s * 0.28, -s * 0.3, s * 0.07, s * 0.04, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(s * 0.28, -s * 0.3, s * 0.07, s * 0.04, 0, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0, -s * 0.22, s * 0.07, 0.1, Math.PI - 0.1); ctx.stroke();
    ctx.fillStyle = 'rgba(255,180,180,0.4)';
    ctx.beginPath(); ctx.ellipse(-s * 0.26, -s * 0.3, s * 0.06, s * 0.035, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(s * 0.26, -s * 0.3, s * 0.06, s * 0.035, 0, 0, Math.PI * 2); ctx.fill();
  }

  // Special decorations
  if (type === TANUKI_TYPES.GOLDEN) {
    ctx.fillStyle = '#FFD700';
    drawStar(0, -s * 0.85, s * 0.15, s * 0.06, 5);
    ctx.globalAlpha = 0.2 + Math.sin(wobble * 5) * 0.1;
    ctx.fillStyle = '#FFD700';
    ctx.beginPath(); ctx.arc(0, -s * 0.2, s * 0.8, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  if (type === TANUKI_TYPES.BOSS) {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(-s * 0.25, -s * 1.0, s * 0.5, s * 0.3);
    ctx.fillRect(-s * 0.35, -s * 0.72, s * 0.7, s * 0.06);
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(-s * 0.25, -s * 0.76, s * 0.5, s * 0.05);
    ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(s * 0.2, -s * 0.42, s * 0.12, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(s * 0.32, -s * 0.42); ctx.lineTo(s * 0.45, -s * 0.1); ctx.stroke();
  }

  if (type === TANUKI_TYPES.SPEEDY) {
    ctx.fillStyle = '#87CEEB';
    ctx.beginPath();
    ctx.moveTo(s * 0.4, -s * 0.55);
    ctx.quadraticCurveTo(s * 0.45, -s * 0.45, s * 0.38, -s * 0.38);
    ctx.quadraticCurveTo(s * 0.35, -s * 0.47, s * 0.4, -s * 0.55);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1.5;
    for (let i = 0; i < 3; i++) {
      const ly = -s * 0.5 + i * s * 0.2;
      ctx.beginPath(); ctx.moveTo(-s * 0.8, ly); ctx.lineTo(-s * 0.5, ly); ctx.stroke();
    }
  }

  if (type === TANUKI_TYPES.ITEM) {
    // Orbiting stars
    for (let i = 0; i < 4; i++) {
      const angle = wobble * 4 + i * Math.PI / 2;
      const orbitX = Math.cos(angle) * s * 0.65;
      const orbitY = Math.sin(angle) * s * 0.35 - s * 0.2;
      ctx.fillStyle = ['#FFD700', '#ff66aa', '#66ffaa', '#66aaff'][i];
      drawStar(orbitX, orbitY, s * 0.08, s * 0.03, 5);
    }
  }

  // Arms
  ctx.fillStyle = bodyColor;
  const armWave = Math.sin(wobble * 6) * 0.3;
  ctx.save();
  ctx.translate(-s * 0.55, -s * 0.05); ctx.rotate(-0.5 + armWave);
  ctx.beginPath(); ctx.ellipse(0, 0, s * 0.12, s * 0.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
  ctx.save();
  ctx.translate(s * 0.55, -s * 0.05); ctx.rotate(0.5 - armWave);
  ctx.beginPath(); ctx.ellipse(0, 0, s * 0.12, s * 0.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.restore();

  ctx.restore();
}

function drawHoleFront(hole) {
  const { x, y } = hole;
  ctx.fillStyle = '#5c3a1e';
  ctx.beginPath();
  ctx.ellipse(x, y + holeRadius * 0.05, holeRadius * 1.05, holeRadius * 0.3, 0, 0, Math.PI);
  ctx.fill();
  ctx.fillStyle = '#7a5030';
  ctx.beginPath();
  ctx.ellipse(x, y - holeRadius * 0.05, holeRadius * 0.95, holeRadius * 0.15, 0, 0, Math.PI);
  ctx.fill();
}

// ===== Tanuki Spawning =====
function spawnTanuki() {
  const available = holes.filter(h => h.tanuki === null);
  if (available.length === 0) return;

  const hole = available[Math.floor(Math.random() * available.length)];

  let type = TANUKI_TYPES.NORMAL;

  if (chanceTimeActive) {
    // Chance time: only rare tanuki, no bombs
    const r = Math.random();
    if (r < 0.3) {
      type = TANUKI_TYPES.BOSS;
    } else if (r < 0.6) {
      type = TANUKI_TYPES.GOLDEN;
    } else if (r < 0.8) {
      type = TANUKI_TYPES.SPEEDY;
    } else {
      type = TANUKI_TYPES.NORMAL;
    }
  } else {
    // Normal spawning
    const r = Math.random();
    const setBonus = (currentSet - 1) * 0.005;

    if (itemSpawnCooldown <= 0 && r < 0.04 + setBonus) {
      type = TANUKI_TYPES.ITEM;
      itemSpawnCooldown = 8; // cooldown before next item
    } else if (r < 0.07 + setBonus * 2) {
      type = TANUKI_TYPES.BOSS;
    } else if (r < 0.13 + setBonus * 2) {
      type = TANUKI_TYPES.GOLDEN;
    } else if (r < 0.20 + currentSet * 0.02) {
      type = TANUKI_TYPES.BOMB;
    } else if (r < 0.30 + setBonus * 2) {
      type = TANUKI_TYPES.SPEEDY;
    }
  }

  // Duration based on type and set difficulty
  const speedFactor = Math.max(0.4, 1 - (currentSet - 1) * 0.1);
  let stayDuration;
  switch (type) {
    case TANUKI_TYPES.SPEEDY:
      stayDuration = (0.5 + Math.random() * 0.3) * speedFactor; break;
    case TANUKI_TYPES.BOSS:
      stayDuration = (1.8 + Math.random() * 0.5) * speedFactor; break;
    case TANUKI_TYPES.GOLDEN:
      stayDuration = (0.8 + Math.random() * 0.4) * speedFactor; break;
    case TANUKI_TYPES.ITEM:
      stayDuration = (1.2 + Math.random() * 0.5) * speedFactor; break;
    default:
      stayDuration = (1.0 + Math.random() * 0.6) * speedFactor;
  }

  // During chance time, tanuki stay a bit longer
  if (chanceTimeActive) stayDuration *= 1.3;

  hole.tanuki = {
    type,
    popProgress: 0,
    phase: 'rising',
    stayDuration,
    stayTimer: 0,
    wobbleTime: Math.random() * 100,
    hit: false,
  };
  totalSpawned++;
}

// ===== Game Logic =====
function resetGame() {
  score = 0;
  combo = 0;
  maxCombo = 0;
  hitCount = 0;
  missCount = 0;
  totalSpawned = 0;
  timeLeft = SET_DURATION;
  level = 1;
  spawnTimer = 0;
  spawnInterval = 1.2;
  particles = [];
  shakeAmount = 0;
  levelUpAnim = 0;
  currentSet = 1;
  setScores = [];
  setHits = [];
  chanceTime = 0;
  chanceTimeActive = false;
  itemSpawnCooldown = 0;
  gameTime = 0;

  for (const h of holes) {
    h.tanuki = null;
    h.hitAnim = 0;
    h.missAnim = 0;
  }

  document.getElementById('score-display').textContent = '0 ÁÇπ';
  document.getElementById('combo-display').textContent = '';
  document.getElementById('timer-display').textContent = SET_DURATION.toString();
  document.getElementById('set-display').textContent = '';
  document.getElementById('level-display').textContent = '';
  document.getElementById('chance-banner').style.display = 'none';
}

function resetSet() {
  timeLeft = SET_DURATION;
  spawnTimer = 0;
  chanceTime = 0;
  chanceTimeActive = false;
  itemSpawnCooldown = 0;
  combo = 0;
  levelUpAnim = 0;

  for (const h of holes) {
    h.tanuki = null;
    h.hitAnim = 0;
    h.missAnim = 0;
  }

  document.getElementById('combo-display').textContent = '';
  document.getElementById('timer-display').textContent = SET_DURATION.toString();
  document.getElementById('chance-banner').style.display = 'none';
}

function startGame() {
  resetGame();
  state = State.PLAYING;
  document.getElementById('message-overlay').classList.add('hidden');
  document.getElementById('set-display').textContent = `„Çª„ÉÉ„Éà 1/${SET_COUNT}`;
  document.getElementById('level-display').textContent = '„Çª„ÉÉ„Éà1 ÔΩû„Ç¶„Ç©„Éº„Éü„É≥„Ç∞„Ç¢„ÉÉ„ÉóÔΩû';
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function startNextSet() {
  resetSet();
  state = State.PLAYING;
  document.getElementById('message-overlay').classList.add('hidden');
  const setTitles = ['', '„Ç¶„Ç©„Éº„Éü„É≥„Ç∞„Ç¢„ÉÉ„Éó', 'Êú¨Áï™ÈñãÂßãÔºÅ', '‰∏≠Áõ§Êà¶ÔºÅ', 'ËøΩ„ÅÑËæº„ÅøÔºÅ', '„Éï„Ç°„Ç§„Éä„É´„Çª„ÉÉ„ÉàÔºÅ'];
  document.getElementById('set-display').textContent = `„Çª„ÉÉ„Éà ${currentSet}/${SET_COUNT}`;
  document.getElementById('level-display').textContent = `„Çª„ÉÉ„Éà${currentSet} ÔΩû${setTitles[currentSet]}ÔΩû`;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function updateGame(dt) {
  if (state !== State.PLAYING) return;

  gameTime += dt;
  timeLeft -= dt;

  // Chance time countdown
  if (chanceTimeActive) {
    chanceTime -= dt;
    if (chanceTime <= 0) {
      chanceTime = 0;
      chanceTimeActive = false;
      document.getElementById('chance-banner').style.display = 'none';
    }
  }

  // Item spawn cooldown
  if (itemSpawnCooldown > 0) {
    itemSpawnCooldown -= dt;
  }

  if (timeLeft <= 0) {
    timeLeft = 0;
    chanceTimeActive = false;
    document.getElementById('chance-banner').style.display = 'none';

    // Record this set's results
    const prevTotal = setScores.reduce((a, b) => a + b, 0);
    setScores.push(score - prevTotal);
    const prevHits = setHits.reduce((a, b) => a + b, 0);
    setHits.push(hitCount - prevHits);

    if (currentSet >= SET_COUNT) {
      showResult();
    } else {
      showSetResult();
    }
    return;
  }

  // Timer display
  const displayTime = Math.ceil(timeLeft);
  const timerEl = document.getElementById('timer-display');
  timerEl.textContent = displayTime.toString();
  if (displayTime <= 3) {
    timerEl.style.color = '#ff3333';
    timerEl.style.fontSize = '28px';
  } else if (displayTime <= 7) {
    timerEl.style.color = '#ffaa33';
    timerEl.style.fontSize = '24px';
  } else {
    timerEl.style.color = '#fff';
    timerEl.style.fontSize = '22px';
  }

  // Spawn tanuki
  spawnTimer += dt;
  const baseInterval = chanceTimeActive
    ? Math.max(0.2, 0.4 - currentSet * 0.03)
    : Math.max(0.35, spawnInterval - currentSet * 0.12);

  if (spawnTimer >= baseInterval) {
    spawnTimer = 0;
    spawnTanuki();
    // Extra spawns in later sets or chance time
    if ((currentSet >= 3 || chanceTimeActive) && Math.random() < 0.35) {
      setTimeout(() => { if (state === State.PLAYING) spawnTanuki(); }, 150);
    }
    if ((currentSet >= 5 || chanceTimeActive) && Math.random() < 0.25) {
      setTimeout(() => { if (state === State.PLAYING) spawnTanuki(); }, 300);
    }
  }

  // Update tanuki in holes
  for (const hole of holes) {
    if (!hole.tanuki) continue;
    const t = hole.tanuki;
    t.wobbleTime += dt;

    switch (t.phase) {
      case 'rising':
        t.popProgress += dt * 4;
        if (t.popProgress >= 1) { t.popProgress = 1; t.phase = 'showing'; }
        break;
      case 'showing':
        t.stayTimer += dt;
        if (t.stayTimer >= t.stayDuration) {
          t.phase = 'sinking';
          if (!t.hit && t.type !== TANUKI_TYPES.BOMB && t.type !== TANUKI_TYPES.ITEM) {
            missCount++;
            combo = 0;
            updateComboDisplay();
          }
        }
        break;
      case 'sinking':
        t.popProgress -= dt * 3;
        if (t.popProgress <= 0) hole.tanuki = null;
        break;
    }

    if (t.hit) {
      t.phase = 'sinking';
      t.popProgress -= dt * 5;
      if (t.popProgress <= 0) hole.tanuki = null;
    }
  }

  // Update hole animations
  for (const hole of holes) {
    if (hole.hitAnim > 0) hole.hitAnim -= dt * 3;
    if (hole.missAnim > 0) hole.missAnim -= dt * 3;
  }

  if (shakeAmount > 0) shakeAmount *= 0.9;
  if (shakeAmount < 0.1) shakeAmount = 0;
  if (levelUpAnim > 0) levelUpAnim -= dt;
}

function handleHit(x, y) {
  if (state !== State.PLAYING) return;

  for (const hole of holes) {
    if (!hole.tanuki || hole.tanuki.hit) continue;
    if (hole.tanuki.phase === 'sinking' && hole.tanuki.popProgress < 0.3) continue;

    const dx = x - hole.x;
    const dy = y - (hole.y - tanukiSize * 0.5 * hole.tanuki.popProgress);
    const hitDist = holeRadius * 1.2;

    if (dx * dx + dy * dy < hitDist * hitDist) {
      const t = hole.tanuki;
      t.hit = true;

      if (t.type === TANUKI_TYPES.BOMB) {
        // Bomb penalty
        const penalty = 30;
        score = Math.max(0, score - penalty);
        combo = 0;
        shakeAmount = 15;
        spawnParticles(hole.x, hole.y - tanukiSize, 25, '#ff3333', 8);
        spawnParticles(hole.x, hole.y - tanukiSize, 15, '#333', 6);
        hole.missAnim = 1;
        const comment = bombHitComments[Math.floor(Math.random() * bombHitComments.length)];
        showFloatingText(hole.x - 60, hole.y - tanukiSize * 2, `-${penalty}ÁÇπÔºÅ`, 'miss-text');
        showFloatingText(hole.x - 80, hole.y - tanukiSize * 2.8, comment, 'miss-text');
        updateComboDisplay();

      } else if (t.type === TANUKI_TYPES.ITEM) {
        // Trigger chance time!
        chanceTime = CHANCE_DURATION;
        chanceTimeActive = true;
        itemSpawnCooldown = 999; // no more items during chance time
        shakeAmount = 10;

        // Clear all current tanuki for dramatic effect
        for (const h of holes) {
          if (h.tanuki && h !== hole) {
            h.tanuki.phase = 'sinking';
          }
        }

        // Big effects
        spawnStars(hole.x, hole.y - tanukiSize, 20);
        spawnParticles(hole.x, hole.y - tanukiSize, 30, '#FFD700', 10);
        spawnParticles(hole.x, hole.y - tanukiSize, 20, '#ff66aa', 8);

        const comment = chanceStartComments[Math.floor(Math.random() * chanceStartComments.length)];
        showFloatingText(canvas.width / 2 - 120, canvas.height * 0.15, comment, 'chance-text');

        document.getElementById('chance-banner').style.display = 'block';

        // Bonus points for catching the item
        score += 30;
        hitCount++;
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        hole.hitAnim = 1;
        showFloatingText(hole.x - 50, hole.y - tanukiSize * 2, '+30 ITEM!', 'bonus-text');
        updateComboDisplay();

      } else {
        // Normal hit scoring
        let points;
        switch (t.type) {
          case TANUKI_TYPES.GOLDEN: points = 50; break;
          case TANUKI_TYPES.BOSS: points = 100; break;
          case TANUKI_TYPES.SPEEDY: points = 20; break;
          default: points = 10;
        }

        // Chance time doubles points
        if (chanceTimeActive) points *= 2;

        combo++;
        if (combo > maxCombo) maxCombo = combo;
        hitCount++;

        const comboMultiplier = 1 + Math.floor(combo / 5) * 0.5;
        points = Math.round(points * comboMultiplier);
        score += points;

        hole.hitAnim = 1;
        shakeAmount = 5;

        const particleColor = t.type === TANUKI_TYPES.GOLDEN ? '#FFD700' :
                              t.type === TANUKI_TYPES.BOSS ? '#ff6600' : '#8B6914';
        spawnParticles(hole.x, hole.y - tanukiSize, 15, particleColor, 6);

        if (t.type === TANUKI_TYPES.GOLDEN || t.type === TANUKI_TYPES.BOSS) {
          spawnStars(hole.x, hole.y - tanukiSize, 10);
        }

        showFloatingText(hole.x - 30, hole.y - tanukiSize * 2, `+${points}`, 'hit-text');

        if (t.type === TANUKI_TYPES.GOLDEN) {
          showFloatingText(hole.x - 50, hole.y - tanukiSize * 2.8, 'Èáë„Åü„Å¨„ÅçÔºÅ', 'bonus-text');
        } else if (t.type === TANUKI_TYPES.BOSS) {
          showFloatingText(hole.x - 60, hole.y - tanukiSize * 2.8, '„Ç≠„É≥„Ç∞„Éù„É≥„Éî„ÉºÔºÅ', 'bonus-text');
        }

        if (comboComments[combo]) {
          showFloatingText(canvas.width / 2 - 100, canvas.height * 0.12, comboComments[combo], 'combo-text');
        }
        updateComboDisplay();
      }

      document.getElementById('score-display').textContent = `${score} ÁÇπ`;
      break;
    }
  }
}

function updateComboDisplay() {
  const el = document.getElementById('combo-display');
  if (combo >= 2) {
    el.textContent = `${combo} COMBO!`;
    el.style.transform = 'scale(1.2)';
    setTimeout(() => { el.style.transform = 'scale(1)'; }, 100);
  } else {
    el.textContent = '';
  }
}

function showSetResult() {
  state = State.SET_RESULT;

  const setScore = setScores[setScores.length - 1];
  const setHit = setHits[setHits.length - 1];
  const comment = setComments[Math.min(currentSet - 1, setComments.length - 1)];

  document.getElementById('message-title').textContent = `„Çª„ÉÉ„Éà ${currentSet} ÁµÇ‰∫ÜÔºÅ`;
  document.getElementById('message-sub').innerHTML =
    `„Åì„ÅÆ„Çª„ÉÉ„Éà„ÅÆ„Çπ„Ç≥„Ç¢: <span style="color:#FFD700">${setScore} ÁÇπ</span><br>` +
    `ÂêàË®à„Çπ„Ç≥„Ç¢: <span style="color:#FFD700;font-size:1.2em">${score} ÁÇπ</span><br>` +
    `„Éí„ÉÉ„ÉàÊï∞: ${setHit}`;
  document.getElementById('message-comment').textContent = comment;
  document.getElementById('message-action').textContent = `„Çø„ÉÉ„Éó„Åß „Çª„ÉÉ„Éà ${currentSet + 1} „Å∏ÔºàÊÆã„Çä ${SET_COUNT - currentSet} „Çª„ÉÉ„ÉàÔºâ`;
  document.getElementById('message-overlay').classList.remove('hidden');

  // Celebration
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      const px = Math.random() * canvas.width;
      const py = canvas.height * 0.3 + Math.random() * canvas.height * 0.3;
      spawnStars(px, py, 6);
    }, i * 200);
  }
}

function showResult() {
  state = State.RESULT;

  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('tanuki_whack_best', bestScore.toString());
  }

  let rating, comments;
  if (score >= 1500) {
    rating = '‰ºùË™¨„ÅÆ„Åü„Å¨„ÅçÂè©„ÅçÂ∏´';
    comments = resultComments.legendary;
  } else if (score >= 1000) {
    rating = '„Åü„Å¨„Åç„Éû„Çπ„Çø„Éº';
    comments = resultComments.great;
  } else if (score >= 600) {
    rating = '‰∏Ä‰∫∫Ââç„ÅÆ„Åü„Å¨„ÅçÂè©„Åç';
    comments = resultComments.good;
  } else if (score >= 250) {
    rating = '„Åü„Å¨„ÅçÂè©„ÅçË¶ãÁøí„ÅÑ';
    comments = resultComments.normal;
  } else {
    rating = '„Åü„Å¨„Åç„ÅÆÂèãÈÅî';
    comments = resultComments.bad;
  }

  const comment = comments[Math.floor(Math.random() * comments.length)];
  const accuracy = totalSpawned > 0 ? Math.round(hitCount / totalSpawned * 100) : 0;

  // Build set breakdown
  let setBreakdown = '';
  for (let i = 0; i < setScores.length; i++) {
    setBreakdown += `„Çª„ÉÉ„Éà${i + 1}: ${setScores[i]}ÁÇπ„ÄÄ`;
  }

  document.getElementById('message-title').textContent = rating;
  document.getElementById('message-sub').innerHTML =
    `<span style="font-size:1.3em;color:#FFD700">ÂêàË®à: ${score} ÁÇπ</span><br>` +
    `<span style="font-size:0.75em">${setBreakdown}</span><br>` +
    `ÊúÄÂ§ß„Ç≥„É≥„Éú: ${maxCombo}„ÄÄÂëΩ‰∏≠Áéá: ${accuracy}%<br>` +
    `<span style="color:#FFD700;font-size:0.8em">„Éô„Çπ„Éà: ${bestScore} ÁÇπ</span>`;
  document.getElementById('message-comment').textContent = comment;
  document.getElementById('message-action').textContent = '„Çø„ÉÉ„Éó / „ÇØ„É™„ÉÉ„ÇØ „Åß„ÇÇ„ÅÜ‰∏ÄÂ∫¶';
  document.getElementById('message-overlay').classList.remove('hidden');

  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      const px = Math.random() * canvas.width;
      const py = canvas.height * 0.3 + Math.random() * canvas.height * 0.3;
      spawnStars(px, py, 8);
      spawnParticles(px, py, 10, ['#FFD700', '#ff6600', '#ff3399', '#33ccff'][i % 4], 5);
    }, i * 300);
  }
}

// ===== Input =====
canvas.addEventListener('click', (e) => {
  if (state === State.PLAYING) handleHit(e.clientX, e.clientY);
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (state === State.PLAYING) {
    for (const touch of e.changedTouches) handleHit(touch.clientX, touch.clientY);
  }
}, { passive: false });

document.getElementById('message-overlay').addEventListener('click', () => {
  if (state === State.TITLE || state === State.RESULT) {
    startGame();
  } else if (state === State.SET_RESULT) {
    currentSet++;
    startNextSet();
  }
});

document.getElementById('message-overlay').addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (state === State.TITLE || state === State.RESULT) {
    startGame();
  } else if (state === State.SET_RESULT) {
    currentSet++;
    startNextSet();
  }
}, { passive: false });

// ===== Main Loop =====
let lastTime = 0;

function loop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  updateGame(dt);
  updateParticles(dt);

  ctx.save();
  if (shakeAmount > 0) {
    ctx.translate(
      (Math.random() - 0.5) * shakeAmount,
      (Math.random() - 0.5) * shakeAmount
    );
  }

  drawBackground();

  const sortedHoles = [...holes].sort((a, b) => a.y - b.y);
  for (const hole of sortedHoles) {
    drawHole(hole);
    if (hole.tanuki && hole.tanuki.popProgress > 0) {
      drawTanuki(hole.x, hole.y, tanukiSize, hole.tanuki.type, hole.tanuki.popProgress, hole.tanuki.wobbleTime);
    }
    drawHoleFront(hole);
  }

  drawParticles();

  if (levelUpAnim > 0) {
    ctx.globalAlpha = levelUpAnim * 0.15;
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;
  }

  // Chance time remaining bar
  if (chanceTimeActive) {
    const barW = canvas.width * 0.6;
    const barH = 8;
    const barX = (canvas.width - barW) / 2;
    const barY = 55;
    const ratio = chanceTime / CHANCE_DURATION;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(barX, barY, barW, barH);
    const grad = ctx.createLinearGradient(barX, 0, barX + barW * ratio, 0);
    grad.addColorStop(0, '#FFD700');
    grad.addColorStop(1, '#ff6600');
    ctx.fillStyle = grad;
    ctx.fillRect(barX, barY, barW * ratio, barH);
  }

  ctx.restore();

  if (state === State.PLAYING || state === State.RESULT || state === State.SET_RESULT) {
    requestAnimationFrame(loop);
  }
}

// ===== Title Screen Animation =====
function animateTitle(timestamp) {
  if (state !== State.TITLE) return;

  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if (Math.random() < 0.02) {
    const available = holes.filter(h => h.tanuki === null);
    if (available.length > 0) {
      const hole = available[Math.floor(Math.random() * available.length)];
      const types = [TANUKI_TYPES.NORMAL, TANUKI_TYPES.GOLDEN, TANUKI_TYPES.NORMAL, TANUKI_TYPES.NORMAL];
      hole.tanuki = {
        type: types[Math.floor(Math.random() * types.length)],
        popProgress: 0, phase: 'rising',
        stayDuration: 1.5 + Math.random(),
        stayTimer: 0, wobbleTime: Math.random() * 100, hit: false,
      };
    }
  }

  for (const hole of holes) {
    if (!hole.tanuki) continue;
    const t = hole.tanuki;
    t.wobbleTime += dt;
    switch (t.phase) {
      case 'rising':
        t.popProgress += dt * 3;
        if (t.popProgress >= 1) { t.popProgress = 1; t.phase = 'showing'; }
        break;
      case 'showing':
        t.stayTimer += dt;
        if (t.stayTimer >= t.stayDuration) t.phase = 'sinking';
        break;
      case 'sinking':
        t.popProgress -= dt * 2;
        if (t.popProgress <= 0) hole.tanuki = null;
        break;
    }
  }

  updateParticles(dt);
  drawBackground();

  const sortedHoles = [...holes].sort((a, b) => a.y - b.y);
  for (const hole of sortedHoles) {
    drawHole(hole);
    if (hole.tanuki && hole.tanuki.popProgress > 0) {
      drawTanuki(hole.x, hole.y, tanukiSize, hole.tanuki.type, hole.tanuki.popProgress, hole.tanuki.wobbleTime);
    }
    drawHoleFront(hole);
  }
  drawParticles();

  requestAnimationFrame(animateTitle);
}

// ===== Init =====
function init() {
  if (bestScore > 0) {
    document.getElementById('message-sub').innerHTML =
      `Á©¥„Åã„ÇâÂá∫„Å¶„Åè„Çã„Åü„Å¨„Åç„ÇíÂè©„ÅëÔºÅ<br><span style="color:#ff4444">Ëµ§„ÅèÂÖâ„Çã„Äå„Éã„Çª„É¢„Éé„Äç„ÅØÂè©„Åè„Å™ÔºÅ</span><br>` +
      `<span style="color:#88ffaa">‚òÖ„Éû„Éº„ÇØ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Åß„ÉÅ„É£„É≥„Çπ„Çø„Ç§„É†ÔºÅ</span><br>` +
      `<span style="color:#FFD700;font-size:0.8em">„Éô„Çπ„Éà: ${bestScore} ÁÇπ</span>`;
  }
  requestAnimationFrame(animateTitle);
}

init();
</script>
</body>
</html>
