<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>„Åü„Å¨„Åç„Éê„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ ü¶ù‚öæ</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #000;
  font-family: 'Segoe UI', 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#ui-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
}

#score-display {
  position: absolute;
  top: max(env(safe-area-inset-top, 0px), 8px);
  left: 0; right: 0;
  text-align: center;
  padding: 8px;
}

#distance {
  font-size: clamp(20px, 5vw, 36px);
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 6px rgba(0,0,0,0.7);
}

#best-score {
  font-size: clamp(13px, 3.2vw, 20px);
  color: #ffe066;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
  margin-top: 2px;
}

#wind-display {
  position: absolute;
  top: max(env(safe-area-inset-top, 0px), 8px);
  right: 12px;
  font-size: clamp(13px, 3.2vw, 18px);
  font-weight: bold;
  color: #fff;
  text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
  padding: 6px 10px;
  background: rgba(0,0,0,0.25);
  border-radius: 8px;
}

#message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: clamp(22px, 6vw, 42px);
  font-weight: bold;
  color: #fff;
  text-shadow: 3px 3px 8px rgba(0,0,0,0.7);
  text-align: center;
  pointer-events: auto;
  line-height: 1.6;
  width: 90%;
  max-width: 500px;
}

#message .sub {
  font-size: clamp(14px, 3.5vw, 20px);
  display: block;
  margin-top: 12px;
  color: #ffe066;
}

/* Bottom controls area */
#controls-area {
  position: absolute;
  bottom: max(env(safe-area-inset-bottom, 0px), 12px);
  left: 0; right: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 0 16px;
}

#angle-display {
  font-size: clamp(16px, 4vw, 22px);
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
  background: rgba(0,0,0,0.3);
  padding: 6px 16px;
  border-radius: 20px;
}

#power-label {
  font-size: clamp(15px, 3.8vw, 20px);
  font-weight: bold;
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
}

#power-bar-container {
  width: min(85vw, 400px);
  height: clamp(28px, 7vw, 40px);
  background: rgba(0,0,0,0.35);
  border-radius: 100px;
  border: 3px solid rgba(255,255,255,0.7);
  overflow: hidden;
}

#power-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #00ff00, #ffff00, #ff8800, #ff0000);
  border-radius: 100px;
  transition: none;
}

/* Tap hint area */
#tap-area {
  position: absolute;
  bottom: max(env(safe-area-inset-bottom, 0px), 12px);
  left: 50%;
  transform: translateX(-50%);
  pointer-events: auto;
  padding: 12px 28px;
  background: rgba(255,255,255,0.15);
  border: 2px solid rgba(255,255,255,0.4);
  border-radius: 16px;
  font-size: clamp(14px, 3.5vw, 18px);
  color: #fff;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
  text-align: center;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.7; transform: translateX(-50%) scale(1); }
  50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
}

.hidden { display: none !important; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui-overlay">
  <div id="score-display">
    <div id="distance">Ë∑ùÈõ¢: 0 m</div>
    <div id="best-score"></div>
  </div>
  <div id="wind-display" class="hidden">È¢®: „Å™„Åó</div>
  <div id="message">
    ü¶ù „Åü„Å¨„Åç„Éê„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ ‚öæ
    <span class="sub">„Çø„ÉÉ„Éó „Åß„Çπ„Çø„Éº„ÉàÔºÅ</span>
  </div>
  <div id="controls-area">
    <div id="angle-display" class="hidden">ËßíÂ∫¶: 45¬∞</div>
    <div id="power-label" class="hidden">„Éë„ÉØ„Éº„ÇíÊ±∫„ÇÅ„ÇçÔºÅ</div>
    <div id="power-bar-container" class="hidden">
      <div id="power-bar"></div>
    </div>
  </div>
  <div id="tap-area" class="hidden">„Çø„ÉÉ„ÉóÔºÅ</div>
</div>

<script>
// ===== Canvas Setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// Logical dimensions (CSS pixels)
function W() { return window.innerWidth; }
function H() { return window.innerHeight; }

// Scale factor: base design is 800px wide
function S() { return Math.min(W(), H()) / 500; }

// ===== Game State =====
const GROUND_Y_RATIO = 0.72;
let groundY;

const State = {
  TITLE: 0,
  AIM_ANGLE: 1,
  AIM_POWER: 2,
  SWING: 3,
  FLYING: 4,
  RESULT: 5,
};

let state = State.TITLE;
let bestDistance = parseFloat(localStorage.getItem('tanuki_best') || '0');

// Physics
let tanukiX, tanukiY, velX, velY;
let angle = 45;
let power = 0;
let powerDir = 1;
let cameraX = 0;
let distance = 0;
let bounceCount = 0;
let swingFrame = 0;

// Batter position
let batterX, batterY;

// Wind
let wind = 0;

// Particles
let particles = [];

// ===== Drawing Helpers =====
function drawSky() {
  const grad = ctx.createLinearGradient(0, 0, 0, H());
  grad.addColorStop(0, '#4a90d9');
  grad.addColorStop(0.5, '#87CEEB');
  grad.addColorStop(0.7, '#b0e0f0');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W(), H());
}

function drawClouds(time) {
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  const s = S();
  for (let i = 0; i < 5; i++) {
    let cx = ((i * 300 * s + time * 0.015 - cameraX * 0.1) % (W() + 200)) - 100;
    let cy = 40 + i * 40 * s;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 50 * s, 20 * s, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx - 25 * s, cy + 8 * s, 35 * s, 16 * s, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 30 * s, cy + 6 * s, 38 * s, 18 * s, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawGround() {
  groundY = H() * GROUND_Y_RATIO;

  const grad = ctx.createLinearGradient(0, groundY, 0, H());
  grad.addColorStop(0, '#4CAF50');
  grad.addColorStop(0.3, '#388E3C');
  grad.addColorStop(1, '#2E7D32');
  ctx.fillStyle = grad;
  ctx.fillRect(0, groundY, W(), H() - groundY);

  // Grass line
  ctx.strokeStyle = '#66BB6A';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(W(), groundY);
  ctx.stroke();
}

function drawDistanceMarkers() {
  const s = S();
  ctx.textAlign = 'center';

  const meterScale = 3 * s;

  for (let m = 50; m < 10000; m += 50) {
    let x = batterX + m * meterScale - cameraX;
    if (x < -20 || x > W() + 20) continue;

    const isMajor = m % 100 === 0;
    ctx.fillStyle = isMajor ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.4)';
    ctx.fillRect(x - 1, groundY - 8, 2, 16);
    if (isMajor) {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.round(11 * s)}px sans-serif`;
      ctx.fillText(m + 'm', x, groundY - 12);
    }
  }
}

function drawTanuki(x, y, size, rotation) {
  const sx = x - cameraX;
  ctx.save();
  ctx.translate(sx, y);
  ctx.rotate(rotation || 0);

  const s = size * S();

  // Body
  ctx.fillStyle = '#8B6914';
  ctx.beginPath();
  ctx.ellipse(0, 0, s, s * 0.8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Belly
  ctx.fillStyle = '#D4A847';
  ctx.beginPath();
  ctx.ellipse(0, s * 0.1, s * 0.6, s * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Face
  ctx.fillStyle = '#8B6914';
  ctx.beginPath();
  ctx.arc(0, -s * 0.7, s * 0.55, 0, Math.PI * 2);
  ctx.fill();

  // Ears
  ctx.fillStyle = '#6B4F12';
  ctx.beginPath();
  ctx.arc(-s * 0.4, -s * 1.1, s * 0.18, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s * 0.4, -s * 1.1, s * 0.18, 0, Math.PI * 2);
  ctx.fill();

  // Eye patches (tanuki markings)
  ctx.fillStyle = '#3E2723';
  ctx.beginPath();
  ctx.ellipse(-s * 0.22, -s * 0.75, s * 0.18, s * 0.14, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(s * 0.22, -s * 0.75, s * 0.18, s * 0.14, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-s * 0.2, -s * 0.78, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s * 0.2, -s * 0.78, s * 0.1, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(-s * 0.18, -s * 0.78, s * 0.05, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s * 0.22, -s * 0.78, s * 0.05, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(0, -s * 0.62, s * 0.06, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * S();
  ctx.beginPath();
  ctx.arc(0, -s * 0.55, s * 0.1, 0.1, Math.PI - 0.1);
  ctx.stroke();

  // Tail
  ctx.fillStyle = '#8B6914';
  ctx.beginPath();
  ctx.ellipse(-s * 0.1, s * 0.6, s * 0.35, s * 0.2, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // Tail stripes
  ctx.fillStyle = '#6B4F12';
  ctx.beginPath();
  ctx.ellipse(-s * 0.15, s * 0.6, s * 0.1, s * 0.18, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawBatter(x, y, swingAngle) {
  const sx = x - cameraX;
  const s = S();
  ctx.save();
  ctx.translate(sx, y);
  ctx.scale(s, s);

  // Body
  ctx.fillStyle = '#333';
  ctx.fillRect(-12, -50, 24, 40);

  // Head
  ctx.fillStyle = '#ffcc99';
  ctx.beginPath();
  ctx.arc(0, -60, 15, 0, Math.PI * 2);
  ctx.fill();

  // Helmet
  ctx.fillStyle = '#1565C0';
  ctx.beginPath();
  ctx.arc(0, -63, 16, Math.PI, 2 * Math.PI);
  ctx.fill();

  // Legs
  ctx.fillStyle = '#555';
  ctx.fillRect(-10, -10, 8, 25);
  ctx.fillRect(2, -10, 8, 25);

  // Bat
  ctx.save();
  ctx.translate(10, -35);
  ctx.rotate(swingAngle);
  ctx.fillStyle = '#D2691E';
  ctx.fillRect(0, -3, 50, 6);
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(46, -5, 8, 10);
  ctx.restore();

  ctx.restore();
}

function drawAngleIndicator() {
  const s = S();
  const sx = batterX - cameraX + 10 * s;
  const sy = batterY - 35 * s;
  const len = 70 * s;
  const rad = -angle * Math.PI / 180;

  ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
  ctx.lineWidth = 3 * s;
  ctx.setLineDash([6 * s, 4 * s]);
  ctx.beginPath();
  ctx.moveTo(sx, sy);
  ctx.lineTo(sx + Math.cos(rad) * len, sy + Math.sin(rad) * len);
  ctx.stroke();
  ctx.setLineDash([]);

  const ax = sx + Math.cos(rad) * len;
  const ay = sy + Math.sin(rad) * len;
  ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax - Math.cos(rad - 0.3) * 12 * s, ay - Math.sin(rad - 0.3) * 12 * s);
  ctx.lineTo(ax - Math.cos(rad + 0.3) * 12 * s, ay - Math.sin(rad + 0.3) * 12 * s);
  ctx.fill();
}

function spawnParticles(x, y, count, color) {
  const s = S();
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8 * s,
      vy: (Math.random() - 1) * 6 * s,
      life: 1,
      color: color || '#FFD700',
      size: (Math.random() * 4 + 2) * s,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15 * S();
    p.life -= 0.02;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x - cameraX, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ===== Game Logic =====
const meterScale = () => 3 * S();

function resetGame() {
  groundY = H() * GROUND_Y_RATIO;
  batterX = 100 * S();
  batterY = groundY;
  tanukiX = batterX - 5 * S();
  tanukiY = groundY - 25 * S();
  velX = 0;
  velY = 0;
  cameraX = 0;
  distance = 0;
  bounceCount = 0;
  swingFrame = 0;
  power = 0;
  powerDir = 1;
  angle = 45;
  wind = (Math.random() - 0.3) * 6;
  particles = [];
}

function startAngle() {
  state = State.AIM_ANGLE;
  document.getElementById('message').classList.add('hidden');
  document.getElementById('angle-display').classList.remove('hidden');
  document.getElementById('wind-display').classList.remove('hidden');
  document.getElementById('tap-area').classList.remove('hidden');
  document.getElementById('tap-area').textContent = '„Çø„ÉÉ„Éó„ÅßËßíÂ∫¶Ê±∫ÂÆöÔºÅ';
  updateWindDisplay();
  angleDir = 1;
}

function updateWindDisplay() {
  const el = document.getElementById('wind-display');
  if (wind > 0.3) el.textContent = `È¢® ‚Üí ${wind.toFixed(1)}`;
  else if (wind < -0.3) el.textContent = `È¢® ‚Üê ${Math.abs(wind).toFixed(1)}`;
  else el.textContent = 'È¢®: „Å™„Åó';
}

let angleDir = 1;
function updateAngle(dt) {
  angle += angleDir * 60 * dt;
  if (angle > 80) { angle = 80; angleDir = -1; }
  if (angle < 10) { angle = 10; angleDir = 1; }
  document.getElementById('angle-display').textContent = `ËßíÂ∫¶: ${Math.round(angle)}¬∞`;
}

function startPower() {
  state = State.AIM_POWER;
  document.getElementById('angle-display').classList.add('hidden');
  document.getElementById('power-label').classList.remove('hidden');
  document.getElementById('power-bar-container').classList.remove('hidden');
  document.getElementById('tap-area').textContent = '„Çø„ÉÉ„Éó„Åß„Éë„ÉØ„ÉºÊ±∫ÂÆöÔºÅ';
}

function updatePower(dt) {
  power += powerDir * 80 * dt;
  if (power > 100) { power = 100; powerDir = -1; }
  if (power < 0) { power = 0; powerDir = 1; }
  document.getElementById('power-bar').style.width = power + '%';
}

function startSwing() {
  state = State.SWING;
  swingFrame = 0;
  document.getElementById('power-label').classList.add('hidden');
  document.getElementById('power-bar-container').classList.add('hidden');
  document.getElementById('tap-area').classList.add('hidden');
}

function updateSwing(dt) {
  swingFrame += dt * 6;
  if (swingFrame >= 1) {
    launch();
  }
}

function launch() {
  state = State.FLYING;
  const s = S();
  const rad = angle * Math.PI / 180;
  const speed = (8 + power * 0.22) * s;
  velX = Math.cos(rad) * speed;
  velY = -Math.sin(rad) * speed;
  spawnParticles(tanukiX, tanukiY, 20, '#ff6600');
}

function updateFlying() {
  const s = S();
  const GRAVITY = 0.18 * s;
  const BOUNCE_DAMPING = 0.45;
  const AIR_RESISTANCE = 0.998;

  velY += GRAVITY;
  velX += wind * 0.0008 * s;
  velX *= AIR_RESISTANCE;
  velY *= AIR_RESISTANCE;

  tanukiX += velX;
  tanukiY += velY;

  const groundHit = groundY - 15 * s;

  if (tanukiY >= groundHit) {
    tanukiY = groundHit;
    if (Math.abs(velY) > 1 * s) {
      velY = -velY * BOUNCE_DAMPING;
      velX *= 0.85;
      bounceCount++;
      spawnParticles(tanukiX, groundY, 8, '#8B6914');
    } else {
      velY = 0;
    }

    if (Math.abs(velX) < 0.3 * s && Math.abs(velY) < 1 * s) {
      showResult();
      return;
    }

    velX *= 0.97;
  }

  distance = Math.max(0, (tanukiX - batterX) / meterScale());

  const targetCam = tanukiX - W() * 0.3;
  cameraX += (targetCam - cameraX) * 0.08;
  if (cameraX < 0) cameraX = 0;

  document.getElementById('distance').textContent = `Ë∑ùÈõ¢: ${Math.round(distance)} m`;
}

function showResult() {
  state = State.RESULT;
  const finalDist = Math.round(distance);

  if (finalDist > bestDistance) {
    bestDistance = finalDist;
    localStorage.setItem('tanuki_best', bestDistance.toString());
  }

  let rating = '';
  if (finalDist < 50) rating = 'üí§ „ÇÇ„Å£„Å®„Åå„Çì„Å∞„ÇåÔºÅ';
  else if (finalDist < 150) rating = 'üëç „Åæ„ÅÇ„Åæ„ÅÇÔºÅ';
  else if (finalDist < 300) rating = 'üî• „Éä„Ç§„Çπ„Éê„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÔºÅ';
  else if (finalDist < 500) rating = '‚≠ê „Åô„Åî„ÅÑÔºÅ„Éõ„Éº„É†„É©„É≥ÔºÅ';
  else rating = 'üèÜ ‰ºùË™¨„ÅÆ„Åü„Å¨„ÅçÊâì„Å°ÔºÅÔºÅ';

  document.getElementById('distance').textContent = `Ë∑ùÈõ¢: ${finalDist} m`;
  document.getElementById('best-score').textContent = `„Éô„Çπ„Éà: ${bestDistance} m`;
  document.getElementById('message').innerHTML =
    `${rating}<br>È£õË∑ùÈõ¢: ${finalDist} m` +
    `<span class="sub">„Çø„ÉÉ„Éó „Åß„ÇÇ„ÅÜ‰∏ÄÂ∫¶</span>`;
  document.getElementById('message').classList.remove('hidden');
  document.getElementById('wind-display').classList.add('hidden');
  document.getElementById('tap-area').classList.add('hidden');

  spawnParticles(tanukiX, tanukiY, 30, '#FFD700');
}

// ===== Input =====
function handleClick(e) {
  if (e) e.preventDefault();
  switch (state) {
    case State.TITLE:
      resetGame();
      startAngle();
      break;
    case State.AIM_ANGLE:
      startPower();
      break;
    case State.AIM_POWER:
      startSwing();
      break;
    case State.RESULT:
      resetGame();
      startAngle();
      break;
  }
}

canvas.addEventListener('click', handleClick);
canvas.addEventListener('touchstart', handleClick, { passive: false });

// Also handle taps on the tap-area button
document.getElementById('tap-area').addEventListener('click', handleClick);
document.getElementById('tap-area').addEventListener('touchstart', handleClick, { passive: false });

// Prevent default touch behaviors globally
document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

// ===== Main Loop =====
let lastTime = 0;
let gameTime = 0;

function loop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;
  gameTime = timestamp;

  // Update
  switch (state) {
    case State.AIM_ANGLE:
      updateAngle(dt);
      break;
    case State.AIM_POWER:
      updatePower(dt);
      break;
    case State.SWING:
      updateSwing(dt);
      break;
    case State.FLYING:
      updateFlying();
      break;
  }

  updateParticles();

  // Draw
  drawSky();
  drawClouds(gameTime);
  drawGround();
  drawDistanceMarkers();

  // Draw batter
  let batAngle = -Math.PI / 3;
  if (state === State.SWING) {
    batAngle = -Math.PI / 3 + swingFrame * (Math.PI * 0.8);
  } else if (state === State.FLYING || state === State.RESULT) {
    batAngle = Math.PI * 0.47;
  }
  drawBatter(batterX, batterY, batAngle);

  // Draw tanuki
  if (state === State.FLYING) {
    drawTanuki(tanukiX, tanukiY, 18, gameTime * 0.01);
  } else if (state === State.RESULT) {
    drawTanuki(tanukiX, tanukiY, 18, 0);
  } else if (state !== State.TITLE) {
    drawTanuki(tanukiX, tanukiY, 18, 0);
  }

  // Angle indicator
  if (state === State.AIM_ANGLE) {
    drawAngleIndicator();
  }

  drawParticles();

  // Flying trail
  if (state === State.FLYING && Math.abs(velX) > 1 * S()) {
    spawnParticles(tanukiX, tanukiY, 1, 'rgba(255,255,255,0.5)');
  }

  requestAnimationFrame(loop);
}

// ===== Init =====
resetGame();
if (bestDistance > 0) {
  document.getElementById('best-score').textContent = `„Éô„Çπ„Éà: ${bestDistance} m`;
}
requestAnimationFrame(loop);
</script>
</body>
</html>
